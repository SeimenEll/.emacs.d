#+STARTUP: indent
* Init Files

#+BEGIN_SRC emacs-lisp
(setq custom-file "~/.emacs.d/.emacs-custom.el")
   (load custom-file)
(setq user-emacs-directory "~/.emacs.d/")
(setq default-directory "~/")
(add-to-list 'load-path "~/.emacs.d/lisp/")
(setq backup-directory-alist `(("." . "~/.backup_emacs")))
#+END_SRC

* Clean Frame

#+BEGIN_SRC emacs-lisp
(tool-bar-mode 0)
(menu-bar-mode 0)
(toggle-scroll-bar -1) 
(defun my/disable-scroll-bars (frame)
  (modify-frame-parameters frame
                           '((vertical-scroll-bars . nil)
                             (horizontal-scroll-bars . nil))))
(add-hook 'after-make-frame-functions 'my/disable-scroll-bars)
#+END_SRC

* Unsorted

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-screen t)

(setq column-number-mode t)
(setq tab-width 4)

(setq ring-bell-function (quote ignore))

(global-auto-revert-mode t)

(setq user-mail-address "sliebelt@eltec.de")
(setq user-full-name "Simon Liebelt")
#+END_SRC

* Solarized Theme

#+BEGIN_SRC emacs-lisp
(use-package solarized-theme
   :ensure t
   :config 
   (setq solarized-use-variable-pitch nil)
   (setq solarized-height-plus-1 1.0)
   (setq solarized-height-plus-2 1.0)
   (setq solarized-height-plus-3 1.0)
   (setq solarized-height-plus-4 1.0)
   (setq solarized-high-contrast-mode-line t)
   (load-theme 'solarized-dark t))
#+END_SRC

* Whitespace mode

#+BEGIN_SRC emacs-lisp
(use-package whitespace
   :ensure t
   :config
   (setq whitespace-style '(face lines-tail))
   :hook (prog-mode-hook whitespace-mode))
#+END_SRC

* Navigation

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-o") 'other-window)
(global-set-key (kbd "M-O") 'other-frame)
(setq next-screen-context-lines 15)
(show-paren-mode 1)
(global-set-key (kbd "M-SPC") 'cycle-spacing)
#+END_SRC

* Org mode

** General

#+BEGIN_SRC emacs-lisp
(require 'org)
(define-key global-map "\C-ca" 'org-agenda)
;;(add-to-list 'auto-mode-alist '("\\.\\(org\\|org_archive\\|txt\\)$" . org-mode))
(add-to-list 'auto-mode-alist '("\\.\\(org\\|org_archive\\)$" . org-mode))
;; KEYWORDS für TODO
(setq org-todo-keywords
      '((sequence "TODO(t)" "|" "DONE(d)" "CANCELED(c)")))
;; TAGS für TODO
(setq org-tag-alist
      '(("@work" . ?w) ("@home" . ?h) ("laptop" . ?l)))

(setq org-capture-templates
      '(("w" ; hotkey
	 "Work task." ; name
	 entry (file "~/Documents/Todos.org")
	 "* TODO %?\n %i")))

(setq org-log-done 'time)

(define-key global-map "\C-cl" 'org-store-link)

(setq org-indent-indentation-per-level 1)

(setq org-adapt-indenation nil)

(setq org-hide-leading-stars 't)

(setq org-hide-emphasis-markers t)

(customize-set-variable 'org-blank-before-new-entry 
                        '((heading . nil)
                          (plain-list-item . nil)))
(setq org-cycle-separator-lines 1)

(setq org-image-actual-width (/ (display-pixel-width) 3))
#+END_SRC

** Code Highlight

#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t
    org-src-tab-acts-natively t
    org-confirm-babel-evaluate nil
    org-edit-src-content-indentation 0)
#+END_SRC

** Agenda

Oeffnet die Agenda im selben Fenster und zerstört nicht das momentane Window-Setup
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-window-setup 'current-window)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq org-agenda-files (list "~/Documents/Todos.org"))
#+END_SRC

** Org-bullet

Org-bullet is pretty laggy.
#+BEGIN_SRC emacs-lisp
(setq locale-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)

(setq org-src-tab-acts-natively t)
(setq org-src-window-setup 'current-window)

(define-key global-map "\C-cc" 'org-capture)
(setq org-export-coding-system 'utf-8)
#+END_SRC

** Summary TODO

#+BEGIN_SRC emacs-lisp
(defun org-summary-todo (n-done n-not-done)
  "Switch entry to DONE when all subentries are done, to TODO otherwise."
  (let (org-log-done org-log-states)   ; turn off logging
    (org-todo (if (= n-not-done 0) "DONE" "TODO"))))

(add-hook 'org-after-todo-statistics-hook 'org-summary-todo)
#+END_SRC

** Org Babel

#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages
'org-babel-load-languages
'((dot . t)))
#+END_SRC

* Auto Fill mode

#+BEGIN_SRC emacs-lisp

(add-hook
 'text-mode-hook
 'auto-fill-mode)

#+END_SRC

* Olivetti Mode

#+BEGIN_SRC emacs-lisp
(add-hook
 'text-mode-hook
 'olivetti-mode)

(setq olivetti-body-width 90)
#+END_SRC

* Ido

+BEGIN_SRC emacs-lisp
(use-package ido
   :ensure t
   :config 
   (setq ido-enable-flex-matching t
         ido-everywhere t
         ido-create-new-buffer 'always
         ido-vertical-define-keys 'C-n-and-C-p-only
         ido-use-filename-at-point (quote guess))
   (setq ido-file-extensions-order
         (quote (".vhd" ".org" ".txt" ".emacs" ".xml" ".el" ".ini" ".cfg" ".cnf")))
   (ido-mode 1))
+END_SRC

* Buffer Move

#+BEGIN_SRC emacs-lisp
(use-package buffer-move
  :ensure t
  :bind (("C-c <up>" . buf-move-up)
         ("C-c <down>" . buf-move-down)
         ("C-c <left>" . buf-move-left)
         ("C-c <right>" . buf-move-right)))
#+END_SRC

* MAGIT

#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :bind ("C-x g" . magit-status))  
#+END_SRC

* Custom Functions

** Whack Whitespace

#+BEGIN_SRC emacs-lisp
    (defun whack-whitespace (arg)
      "Delete all white space from point to the next word.  With prefix ARG
    delete across newlines as well.  The only danger in this is that you
    don't have to actually be at the end of a word to make it work.  It
    skips over to the next whitespace and then whacks it all to the next
    word."
      (interactive "P")
      (let ((regexp (if arg "[ \t\n]+" "[ \t]+")))
        (re-search-forward regexp nil t)
        (replace-match "" nil nil)))

#+END_SRC

* Time

#+BEGIN_SRC emacs-lisp
(display-time)
#+END_SRC

* Google

#+BEGIN_SRC emacs-lisp
(use-package google-this
  :ensure t
  :config 
  (google-this-mode 1))  
#+END_SRC

* Tiny Expand

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-;") #'tiny-expand)
#+END_SRC

* Dired

** Subtree

#+BEGIN_SRC emacs-lisp
(use-package dired-subtree
  :ensure t
  :config
  (bind-keys :map dired-mode-map
             ("i" . dired-subtree-insert)
             (";" . dired-subtree-remove)))
#+END_SRC

* Ivy

#+BEGIN_SRC emacs-lisp
(use-package ivy
  :ensure t
  :ensure swiper
  :ensure counsel
  :config 
  (setq ivy-use-virtual-buffers t
        enable-recursive-minibuffers t)
  :bind (("\C-s" . swiper)
         ("C-c C-r" . ivy-resume)
         ("<f6>" . ivy-resume)
         ("M-x" . counsel-M-x)
         ("C-x b" . counsel-switch-buffer)
         ("C-x r b" . counsel-bookmark)
         ("C-x C-f" . counsel-find-file)
         ("<f1> f" . counsel-describe-function)
         ("<f1> v" . counsel-describe-variable)
         ("<f1> l" . counsel-find-library)
         ("<f2> i" . counsel-info-lookup-symbol)
         ("<f2> u" . counsel-unicode-char)
         ("C-x l" . counsel-locate)
         ("C-S-o" . counsel-rhythmbox)
         ("C-r" . counsel-minibuffer-history)))
#+END_SRC

** Posframe

#+BEGIN_SRC emacs-lisp
(use-package ivy-posframe
  :ensure t
  :config
  (setq ivy-posframe-display-functions-alist 
      '((swiper . nil)
        (complete-symbol . ivy-posframe-display-at-point)
        (counsel-M-x . ivy-posframe-display-at-frame-center)
        (t . ivy-posframe-display-at-frame-center)))
  (ivy-posframe-mode 1))
#+END_SRC

* Dict.cc

#+BEGIN_SRC emacs-lisp
(use-package dictcc
  :ensure t
  :bind (("C-c d d" . dictcc)
         ("C-c d w" . dictcc-at-point)))
#+END_SRC

* VHDL-Mode

#+BEGIN_SRC emacs-lisp
(use-package vhdl-mode
  :ensure t
  :config
  (setq vhdl-basic-offset 3)
  (setq vhdl-company-name "ELTEC Elektronik AG")
  (setq vhdl-copyright-string"-- Copyright (c) <year> <company>")
  (setq vhdl-electric-mode nil)
  (setq vhdl-end-comment-column 99)
  (setq vhdl-stutter-mode t)
  (setq vhdl-upper-case-enum-values t)
  (setq vhdl-platform-spec "WIN10")
  (setq vhdl-file-header
	"-------------------------------------------------------------------------------
-- Title      : <title string>
-- Project    : <project>
-------------------------------------------------------------------------------
-- File       : <filename>
-- Author     : <author>
-- Company    : <company>
-- Created    : <date>
-- Last update: <date>
-- Platform   : <platform>
-- Standard   : <standard>
<projectdesc>-------------------------------------------------------------------------------
-- Description: <cursor>
<copyright>
-------------------------------------------------------------------------------"))
#+END_SRC

* Which-Key

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :config (which-key-mode)
          (setq which-key-idle-delay 0.5))
#+END_SRC
* Company
#+BEGIN_SRC elisp
(use-package company
  :ensure t
  :config
  (add-to-list 'company-backends 'hledger-company)
  (setq company-auto-complete nil
        company-tooltip-flip-when-above t
        company-minimum-prefix-length 2
        company-tooltip-limit 10
        company-idle-delay 0.5)
  (global-company-mode 1)
  (add-hook 'after-init-hook 'global-company-mode)
  (global-set-key (kbd "M-/") 'company-complete-common-or-cycle))
#+END_SRC
* hledger
#+BEGIN_SRC elisp
(use-package hledger-mode
  :ensure t
  :config
 (add-to-list 'auto-mode-alist '("\\.journal\\'" . hledger-mode))
 (setq hledger-jfile "~/Documents/ledger/2022.journal"))
#+END_SRC
* Flycheck
#+BEGIN_SRC elisp
(use-package flycheck
  :ensure t
  :init (global-flycheck-mode))
#+END_SRC
** Color-Modeline
#+BEGIN_SRC elisp
(use-package flycheck-color-mode-line
  :ensure t
  :init (eval-after-load "flycheck"
  '(add-hook 'flycheck-mode-hook 'flycheck-color-mode-line-mode)))
#+END_SRC
** Pos-Tip
#+BEGIN_SRC elisp
(use-package flycheck-pos-tip
  :ensure t
  :init (with-eval-after-load 'flycheck
  (flycheck-pos-tip-mode)))
#+END_SRC
